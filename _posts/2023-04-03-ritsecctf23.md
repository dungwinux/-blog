---
layout: post
title: "RITSEC CTF 2023 - Gauntlet writeup"
date: 2022-04-03 05:30:00 +0000
categories: security
tags: ctf
---

This year is my first take on [RITSEC CTF](https://ctftime.org/event/1860).
Members of my team solved most of the challenges.
I only solve one reversing challenge, Gauntlet,
because it is particularly interesting to me.
This post will also be my first public write-up after a long time.

> Gauntlet - 250 points
> 
> Four parts of a key are being assembled within this file. The adversary has implemented four corresponding anti-debug checks that need to be bypassed. Good luck!

The challenge simply asks the player to bypass four anti-debugging mechanisms
to receive the flag. It only provides a binary, which raises two questions:
-   Where is the flag stored?
-   Since there are anti-debugging mechanism, will the program print out
the flag when running the challenge without debugger?

Considering the challenge description, it is likely the flag stored in memory at runtime.
As to what happen when running, sadly, that is not expected when we
open the binary in decompiler.

After running through each of the mechanism,
a part of the flag is copied into a specific buffer on stack,
as if they were concatnated. In the end there are no printing on console
other than the message that inform which mechanism has been bypassed.

What if we extract the string instead?
Turns out, this is possible, although not obvious.
Cutter/Rizin has ability to demangle C++ symbol, and we were able to find
a symbol named `ay::obfuscated_data`.
Searching this online reveals a library it uses to encrypt the
flag at compile-time and decrypt it in runtime:
[adamyaxley:Obfuscate](https://github.com/adamyaxley/Obfuscate).
The library XOR the data using 64-bit little-endian key. Since template data
is also stored in debug symbol, we also know the initial template parameter: data size and key. This data here are XOR-encrypted but still stored
in the binary, so we simply find them and XOR again to reveal the data behind.

For example, here we can find the encrpyted string of the first part of the flag.

```cpp
iVar4 = FirstChallenge(char*, int*)::{lambda()#1}::operator()() const((int64_t)&var_21h);
*(undefined8 *)0x0 = ay::obfuscated_data<16ull, 3004872806184872195ull>::operator char*()(iVar4);
```

It looks ugly, but bear with me, this is just C++. Here is how the
"compile-time encrpyted string" library works at runtime.
The lambda call in the first line abstracts the instantiation of `ay::obfuscated_data`,
decryption of the data, and store decrypted data at the memory which can be referred
through `iVar4`, which is likely an `ay::obfuscated_data` object.
The second line is just C-string casting call, likely to access the underlying
decrypted data. We can confirm this by looking at the library source code
[adamyaxley:Obfuscate/obfuscate.h#L205-L213](https://github.com/adamyaxley/Obfuscate/blob/674a53f34c05a1dd092561face7a6807f921d223/obfuscate.h#L205-L213)

Now let's try to decrypt data given the template above. We know 16 is the size,
and the encryption key (according the `cipher` function in library) is
`03 69 E1 8F E5 73 B3 29`. Now for the data, let's inpsect the lambda code.
In first few lines of assembly, it seems like we have found it:

```s
mov byte [arg2], 0x51
mov byte [var_27h], 0x3a 
mov byte [var_26h], 0x9a 
mov byte [var_25h], 0xde 
mov byte [var_24h], 0x90 
mov byte [var_23h], 0x1a 
mov byte [var_22h], 0xd0 
mov byte [var_21h], 0x42 
mov byte [var_20h], 0x5c 
mov byte [var_1fh], 0xa
mov byte [var_1eh], 0x89 
mov byte [var_1dh], 0xea 
mov byte [var_1ch], 0x86 
mov byte [var_1bh], 0x18 
mov byte [var_1ah], 0xec 
mov byte [var_19h], 0x29 
```

The number of line is 16, so it cannot be wrong. And with that, we can find
the first part of the flag: `RS{Quick_check_`

Spending one hour on this to extract and concatnate data, I was able to extract
all instances of `ay::obfuscated_data`.
But when concanating, the output does not look like a flag at all.
It seems like there are additional conditions during copies.
Instead of figuring out the conditions, I attempt running the binary this time.
Opening in the binary in Windows Sandbox,
the program runs like what I expect from reading decompiled code in Cutter.

![Running in sandbox]({{ "/assets/images/ritsecctf23_AtLQ2Uc3Cb.png" | relative_url }})

Suddenly, I have another idea. Since the buffer that likely stores flag is on stack,
which is predictable, can we modify the binary to print it out instead?
This idea comes out partially due to the fact that I was revising for midterm
of one of my course. I don't find any integrity checking in the binary,
and anti-debugging mechanisms likely have nothing to do with binary integrity.
Additionally, the binary was statically compiled, meaning `printf` can be
referenced easily.

Luckily, we don't have to go far. After the forth part of the flag is copied,
before the end of the `main` function, I find a `printf` call printing out
"_C4: No check available.\n_".

![Bug in gauntlet]({{ "/assets/images/ritsecctf23_gauntlet_bug.png" | relative_url }})

`printf` call receives the format string address stored in `rcx` register.
`rcx` is copied from `rax`, which in turn is computed by `lea` instruction.

Meanwhile, thanks to the `memset` function call at the beginning of `main` function,
it is easily to calculate the offset of buffer that is suspected to be the flag:
`rbp - 0xc0`.

![Secret of gauntlet]({{ "/assets/images/ritsecctf23_gauntlet_secret.png" | relative_url }})

With that, we will change the last print call to use the address of the suspected location of the flag instead.
One way is to open Ghidra, click on the `lea` assembly line, right-click, and select Patch Instruction.
Then we can rewrite the instruction as we like and then export it.
The other way is to search for those assembly bytes in the hex dump and directly modify it. I chose the latter.

Old code:
```
$ cstool "x64" "48 8d 05 70 9c 01 00"
 0  48 8d 05 70 9c 01 00        lea        rax, [rip + 0x19c70]
```

New code:

```
$ kstool "x64" "lea rdx, [rbp - 0xc0]"
lea rdx, [rbp - 0xc0] = [ 48 8d 95 40 ff ff ff ]
```

When modifying binary, it is best not to change the size of the function. I used
Keystone to generate assembly, and luckily, the new code has a similar size of 7.
Opening the binary in HxD, I search for the original code bytes and replace them.
Then I copied the "patched" binary to the virtual machine to test it.
As expected, it prints out the flag without a debugger.

![Exploitation of gauntlet]({{ "/assets/images/ritsecctf23_ZxzQNPBpoD.png" | relative_url }})

However, during the competition, it seems like the intended solution
assumes the presence of a debugger, so the server flag is different from my submitted flag. According to the author's fix note,
the program can incorrectly generate the fourth part of the flag depending on the debugger in use.
From my perspective, this issue remains even when the debugger does not exist, which makes no sense.
My flag was accepted anyway after the challenge was updated.

Overall, this is a fun challenge for me to learn the fact that static analysis
sometimes can be useful in practice when dynamic analysis is difficult.
